#!/usr/bin/env python3
"""Convenience wrapper for the OSQAr CLI.

This repository is documentation-first (`package-mode = false`), so we provide a
thin executable wrapper that invokes the stdlib-only CLI implementation.

Usage:
  ./osqar --help

This wrapper prefers Poetry-managed execution when available.

Fallback (no execute bit):
  python ./osqar --help
"""

from __future__ import annotations

import os
import os.path
import shutil
import subprocess
import sys
from pathlib import Path


def _run(argv: list[str]) -> int:
  try:
    return int(subprocess.run(argv).returncode)
  except FileNotFoundError as exc:
    print(f"ERROR: command not found: {argv[0]} ({exc})", file=sys.stderr)
    return 127


if __name__ == "__main__":
  # Prefer the user's logical working directory (symlink/case-preserving) when the
  # wrapper is invoked from the repo root. This avoids surprising path rewrites on
  # macOS (e.g., `open-docs --print-only`).
  physical_root = Path(__file__).resolve().parent
  repo_root = physical_root
  pwd = os.environ.get("PWD")
  if pwd:
    try:
      if os.path.isdir(pwd) and os.path.samefile(pwd, physical_root):
        repo_root = Path(pwd)
    except OSError:
      pass

  os.chdir(repo_root)

  # If we're already running inside `poetry run`, avoid spawning Poetry again.
  if os.environ.get("POETRY_ACTIVE") == "1":
    from tools.osqar_cli import main

    raise SystemExit(main())

  if shutil.which("poetry"):
    raise SystemExit(
      _run(["poetry", "run", "python", "-m", "tools.osqar_cli", *sys.argv[1:]])
    )

  # Last resort: run in the current interpreter environment.
  raise SystemExit(_run([sys.executable, "-m", "tools.osqar_cli", *sys.argv[1:]]))
