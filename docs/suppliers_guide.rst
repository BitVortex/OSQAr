================
Supplierâ€™s Guide
================

Scope
=====

This guide is for a **supplier** shipping a component/SEooC together with compliance-ready documentation.

The goal is to provide a package that allows an integrator to:

- understand intended use and limitations
- reuse evidence where appropriate
- complete context-specific safety analysis and verification

Supplier deliverables
=====================

Documentation deliverables
--------------------------

Provide a structured documentation set:

- safety goals and safety requirements (``REQ_SAFETY_*``)
- functional requirements (``REQ_FUNC_*``)
- architecture/design constraints (``ARCH_*``)
- verification requirements and methods (``TEST_*``)
- traceability matrices demonstrating coverage

Operational assumptions (critical)
----------------------------------

Document assumptions clearly:

- environment ranges (temperature, vibration, EMC/noise)
- sampling rates, timing budgets, scheduling assumptions
- sensor characteristics and calibration assumptions
- expected failure modes and diagnostic coverage boundaries

Interface specification
-----------------------

Provide stable interface definitions:

- signal names, units, ranges, validity rules
- error reporting behavior
- initialization and degraded mode behavior
- timing constraints and performance limits

Verification artifacts
----------------------

Provide machine-readable test output when possible (e.g., JUnit XML), and record tool versions/configuration.

Traceability export and shipment integrity
------------------------------------------

In OSQAr, an example build output directory can be treated as a **software shipment**: it is the unit that is
transferred to the integrator and stored as evidence.

For each shipped example output, include the following files **inside the shipped directory**:

- ``needs.json``: machine-readable export of all requirements/architecture/tests (from ``sphinx-needs``)
- ``traceability_report.json``: machine-readable check result (generated by OSQAr tooling)
- ``SHA256SUMS``: checksum manifest for the entire shipped directory (generated by OSQAr tooling)
- ``osqar_project.json``: optional project metadata (description, URLs, origin)

Recommended supplier procedure (per example)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

1. Build the example documentation (this emits HTML plus ``needs.json``)::

	poetry run sphinx-build -b html \
		examples/python_hello_world \
		examples/python_hello_world/_build/html

2. Run traceability checks and write a JSON report::

	poetry run python tools/traceability_check.py \
		examples/python_hello_world/_build/html/needs.json \
		--json-report examples/python_hello_world/_build/html/traceability_report.json

3. Generate a checksum manifest for the example build output directory and verify it immediately::

	poetry run python tools/generate_checksums.py \
		--root examples/python_hello_world/_build/html \
		--output examples/python_hello_world/_build/html/SHA256SUMS

	poetry run python tools/generate_checksums.py \
		--root examples/python_hello_world/_build/html \
		--verify examples/python_hello_world/_build/html/SHA256SUMS

Optional convenience: the same steps are available via the OSQAr CLI::

	# One-shot supplier workflow (recommended)
	poetry run python -m tools.osqar_cli supplier prepare \
		--project examples/python_hello_world \
		--clean \
		--archive

	# Or run the individual shipment steps
	poetry run python -m tools.osqar_cli shipment build-docs --project examples/python_hello_world
	poetry run python -m tools.osqar_cli shipment traceability --shipment examples/python_hello_world/_build/html
	poetry run python -m tools.osqar_cli shipment checksums --shipment examples/python_hello_world/_build/html generate
	poetry run python -m tools.osqar_cli shipment checksums --shipment examples/python_hello_world/_build/html verify

	# Legacy equivalents (still supported)

	poetry run python -m tools.osqar_cli traceability examples/python_hello_world/_build/html/needs.json \
		--json-report examples/python_hello_world/_build/html/traceability_report.json

	poetry run python -m tools.osqar_cli checksum generate \
		--root examples/python_hello_world/_build/html \
		--output examples/python_hello_world/_build/html/SHA256SUMS

	poetry run python -m tools.osqar_cli checksum verify \
		--root examples/python_hello_world/_build/html \
		--manifest examples/python_hello_world/_build/html/SHA256SUMS

4. Ship the example build output directory as an archive (ZIP/TAR), keeping ``SHA256SUMS`` at the root of
	the shipped directory.

Optional: add project metadata into the shipment directory (recommended for multi-project integrators)::

	poetry run python -m tools.osqar_cli shipment metadata write \
		--shipment examples/python_hello_world/_build/html \
		--name "OSQAr Python Hello World" \
		--version "0.2.3" \
		--url repository=https://example.com/repo.git \
		--origin url=https://example.com/repo.git \
		--origin revision=<commit>

Notes
^^^^^

- Generate checksums **per example build output**, not site-wide. The OSQAr framework docs (repo root build)
	are not part of the example shipment.
- Keep requirement IDs stable across releases; the exported artifacts are designed to be diffed and archived.
- For higher assurance, sign ``SHA256SUMS`` externally (e.g., detached signature) and store it separately from
	the shipment.

Change control and versioning
=============================

Version the supplier package and include:

- a changelog describing safety-impacting changes
- compatibility notes (interfaces, configuration)
- migration guidance for integrators

How to use OSQAr as a supplier
==============================

- Start from the reference chapter structure and keep it consistent.
- Treat requirement IDs as a contract; keep them stable across releases.
- Provide review-friendly traceability with both ``:links:`` and explicit tables.
- Ship an evidence bundle (rendered HTML, sources, diagrams, test outputs, toolchain metadata).

Integrator handoff
==================

Clarify:

- intended use and out-of-scope behavior
- assumptions that must be validated during integration
- safety-relevant configuration parameters
- what evidence is reusable vs must be redone in context
