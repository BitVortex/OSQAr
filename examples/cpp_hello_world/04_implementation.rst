==========================
Implementation & Test Code
==========================

.. need:: (CODE) Implementation follows requirement IDs and architecture specifications.
   :id: CODE_IMPL_001
   :status: active
   :tags: implementation, code, traceability
   :links: ARCH_001, ARCH_FUNC_001, ARCH_FUNC_002, ARCH_FUNC_003

   The C++ implementation captures traceability via structured comments and stable interfaces.

.. need:: (TEST) Test suite provides coverage of requirements.
   :id: TEST_CODE_001
   :status: active
   :tags: verification, testing, code

   The native test runner writes `test_results.xml` in JUnit format and maps to the `TEST_*` needs.

.. need:: (CODE) Complete example includes both documentation and implementation.
   :id: CODE_REPO_001
   :status: active
   :tags: repository, structure

   This example keeps documentation (`*.rst`) next to the C++ source and test artifacts for end-to-end traceability.

Code Organization
=================

This TSIM implementation is written in **C++** and keeps the same requirement IDs as the reference example.

.. code-block:: text

    examples/cpp_hello_world/
    ├── include/
    │   └── tsim.hpp
    ├── src/
    │   └── tsim.cpp
    ├── tests/
    │   └── test_tsim.cpp        # Native test runner writing JUnit XML
    ├── CMakeLists.txt
    ├── test_results.xml         # Generated by ./build-and-test.sh
    └── build-and-test.sh

Traceability in C++ Code
========================

In C/C++ projects, requirement traceability is typically captured via:

- structured comments (e.g., `REQ_FUNC_001`, `TEST_CONVERSION_001`)
- public headers as architecture artifacts (interfaces)

The API in `include/tsim.hpp` maps directly to:

- :need:`REQ_FUNC_001` (ADC conversion)
- :need:`REQ_FUNC_002` (5-sample moving average)
- :need:`REQ_FUNC_003` / :need:`REQ_FUNC_004` (threshold + hysteresis)

Building & Running Tests
========================

.. code-block:: bash

   cd examples/cpp_hello_world

   # Build
   cmake -S . -B build
   cmake --build build

   # Run tests (writes JUnit XML)
   ./build/junit_tests test_results.xml

Then build the documentation (imports `test_results.xml`):

.. code-block:: bash

   osqar build-docs --project examples/cpp_hello_world
