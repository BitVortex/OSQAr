"""Sphinx configuration for the OSQAr Rust hello_world example."""

from __future__ import annotations

import os
import shutil
import subprocess
import sys
from pathlib import Path


# Add repo root to path (allows importing shared helpers if needed)
root_dir = Path(__file__).parent.parent.parent
sys.path.insert(0, str(root_dir))


project = 'OSQAr: Temperature Monitor (Rust)'
copyright = '2025, OSQAr Contributors'
author = 'OSQAr Team'


extensions = [
    'sphinx_needs',
    'sphinxcontrib.plantuml',
]

try:
    import sphinxcontrib.test_reports  # noqa: F401
except ModuleNotFoundError:
    print('! sphinx-test-reports not installed; test result import disabled')
else:
    extensions.append('sphinxcontrib.test_reports')


# Theme
html_theme = os.environ.get('OSQAR_SPHINX_THEME', 'furo')
html_static_path = ['_static']
html_css_files = ['custom.css']

# Keep indices tidy: examples are not API references.
html_use_index = False
html_domain_indices = False
html_use_modindex = False


# Prevent Bazel (and other build tools) from polluting the Sphinx source tree.
# Bazel creates `bazel-*` symlinks/directories in the workspace which may
# contain a full copy of the source tree, causing duplicate documents/need IDs.
exclude_patterns = [
    '_build',
    'build',
    '.venv',
    '__pycache__',
    'bazel-*',
    'bazel-bin',
    'bazel-out',
    'bazel-testlogs',
]


# sphinx-needs
needs_id_regex = '^[A-Z0-9_]{3,}'
needs_css = 'modern.css'

# Export a reproducible needs.json alongside HTML builds.
needs_build_json = True
needs_reproducible_json = True


# sphinx-test-reports (optional)
# The JUnit XML is generated by `./build-and-test.sh`. Do not commit generated
# artifacts; documentation builds must tolerate missing test output.
test_results_file = Path(__file__).parent / 'test_results.xml'
test_reports = ['test_results.xml'] if test_results_file.exists() else []


# Coverage report (embedded in HTML via literalinclude)
def _ensure_coverage_report() -> None:
    report_path = Path(__file__).parent / 'coverage_report.txt'
    if report_path.exists():
        return
    report_path.write_text(
        'Code coverage report not generated in this build.\n'
        'If you want Rust code coverage evidence, install cargo-llvm-cov and run:\n'
        '  OSQAR_COVERAGE=1 ./build-and-test.sh\n',
        encoding='utf-8',
    )


# Complexity report (embedded in HTML via literalinclude)
def _write_complexity_report() -> None:
    report_path = Path(__file__).parent / 'complexity_report.txt'

    try:
        # Prefer a Rust-specific tool if present, fall back to lizard.
        if shutil.which('cargo-cyclo'):
            result = subprocess.run(
                ['cargo', 'cyclo'],
                cwd=Path(__file__).parent,
                capture_output=True,
                text=True,
            )
            report_path.write_text(result.stdout + (result.stderr or ''), encoding='utf-8')
        elif shutil.which('lizard'):
            result = subprocess.run(
                ['lizard', '-C', '10', 'src'],
                cwd=Path(__file__).parent,
                capture_output=True,
                text=True,
            )
            report_path.write_text(result.stdout + (result.stderr or ''), encoding='utf-8')
        else:
            report_path.write_text(
                'No complexity tool is available in this environment.\n'
                'Install one of:\n'
                '- poetry install (dev deps)  # provides lizard\n'
                '- cargo install cargo-cyclo\n',
                encoding='utf-8',
            )
    except Exception as exc:  # noqa: BLE001
        report_path.write_text(f'Failed to generate complexity report: {exc}\n', encoding='utf-8')


_write_complexity_report()
_ensure_coverage_report()


# PlantUML
plantuml_output_format = 'svg'

env_jar = os.environ.get('PLANTUML_JAR')
if env_jar and Path(env_jar).is_file():
    plantuml = f'java -jar "{env_jar}"'
    print(f"✓ Using PLANTUML JAR from environment: {env_jar}")
elif env_jar:
    print(f"! PLANTUML_JAR is set but not found at: {env_jar}; falling back")

if 'plantuml' not in globals() and 'plantuml_server' not in globals():
    if shutil.which('plantuml'):
        plantuml = 'plantuml'
        print("✓ Using system 'plantuml' command")
    elif shutil.which('java'):
        jar_paths = [
            '/opt/plantuml/plantuml.jar',
            '/usr/share/plantuml/plantuml.jar',
            '/usr/local/opt/plantuml/libexec/plantuml.jar',
        ]
        for jar_path in jar_paths:
            try:
                subprocess.run(
                    ['java', '-jar', jar_path, '-version'],
                    capture_output=True,
                    check=True,
                    timeout=5,
                )
                plantuml = f'java -jar "{jar_path}"'
                print(f"✓ Using PlantUML JAR: {jar_path}")
                break
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
                continue
        else:
            print('! PlantUML JAR not found; using web service')
            plantuml_server = 'https://www.plantuml.com/plantuml'
    else:
        print('! PlantUML and Java not found; using web service (requires internet)')
        plantuml_server = 'https://www.plantuml.com/plantuml'


plantuml_output_directory = '_diagrams'
if Path('diagrams').exists():
    Path(plantuml_output_directory).mkdir(parents=True, exist_ok=True)
